{"pageContext":{"html":"<h1 id=\"general-design-considerations\"><a href=\"#general-design-considerations\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>General Design Considerations</h1>\n<p>Since you only need to describe the structure of the data to expose, API Platform is both <a href=\"https://swagger.io/blog/api-design/design-first-or-code-first-api-development/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a \"design-first\" and \"code-first\"</a>\nAPI framework. However, the \"design-first\" methodology is strongly recommended: first you design the <strong>public shape</strong> of\nAPI endpoints.</p>\n<p>To do so, you have to write a plain old PHP object representing the input and output of your endpoint. This is the class\nthat is <a href=\"/docs/distribution/index/\">marked with the <code class=\"language-text\">@ApiResource</code> annotation</a>.\nThis class <strong>doesn't have</strong> to be mapped with Doctrine ORM, or any other persistence system. It must be simple (it's usually\njust a data structure with no or minimal behaviors) and will be automatically converted to <a href=\"/docs/core/extending-jsonld-context/\">Hydra</a>,\n<a href=\"/docs/core/swagger/\">OpenAPI</a> and <a href=\"/docs/core/graphql/\">GraphQL</a> documentations or schemas by API Platform (there is a 1-1 mapping\nbetween this class and those docs).</p>\n<p>Then, it's up to the developer to feed API Platform with an hydrated instance of this API resource object by implementing\nthe <a href=\"/docs/core/data-providers/\"><code class=\"language-text\">DataProviderInterface</code></a>. Basically, the data provider will query the persistence system (RDBMS,\ndocument or graph DB, external API...), and must hydrate and return the POPO that has been designed as mentioned above.</p>\n<p>When updating a state (<code class=\"language-text\">POST</code>, <code class=\"language-text\">PUT</code>, <code class=\"language-text\">PATCH</code>, <code class=\"language-text\">DELETE</code> HTTP methods), it's up to the developer to properly persist the\ndata provided by API Platform's resource object <a href=\"/docs/core/serialization/\">hydrated by the serializer</a>.\nTo do so, there is another interface to implement: <a href=\"/docs/core/data-persisters/\"><code class=\"language-text\">DataPersisterInterface</code></a>.</p>\n<p>This class will read the API resource object (the one marked with <code class=\"language-text\">@ApiResource</code>) and:</p>\n<ul>\n<li>persist it directly in the database;</li>\n<li>or hydrate a DTO then trigger a command;</li>\n<li>or populate an event store;</li>\n<li>or persist the data in any other useful way.</li>\n</ul>\n<p>The logic of data persisters is the responsibility of application developers, and is <strong>out of the API Platform's scope</strong>.</p>\n<p>For <a href=\"https://en.wikipedia.org/wiki/Rapid_application_development\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rapid Application Development</a>, convenience and prototyping,\n<strong>if and only if the class marked with <code class=\"language-text\">@ApiResource</code> is also a Doctrine entity</strong>, the developer can use the Doctrine\nORM's data provider and persister implementations shipped with API Platform.</p>\n<p>In this case, the public (<code class=\"language-text\">@ApiResource</code>) and internal (Doctrine entity) data model are shared. Then, API Platform will\nbe able to query, filter, paginate and persist data automatically.\nThis approach is super-convenient and efficient, but is probably <strong>not a good idea</strong> for non-<a href=\"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CRUD</a>\nand/or large systems.\nAgain, it's up to the developers to use, or to not use these built-in data providers/persisters depending on the business logic\nthey are dealing with.\nAPI Platform makes it easy to create custom data providers and persisters.\nIt also makes it easy to implement patterns such as <a href=\"https://www.martinfowler.com/bliki/CommandQuerySeparation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CQS</a>\nor <a href=\"https://martinfowler.com/bliki/CQRS.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CQRS</a> thanks to <a href=\"/docs/core/messenger/\">the Messenger Component integration</a> and the <a href=\"/docs/core/dto/\">DTO support</a>.</p>\n<p>Last but not least, to create <a href=\"https://martinfowler.com/eaaDev/EventSourcing.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Event Sourcing</a>-based systems, a convenient\napproach is:</p>\n<ul>\n<li>to persist data in an event store using a Messenger handler or a custom <a href=\"/docs/core/data-persisters/\">data persister</a></li>\n<li>to create projections in standard RDBMS (Postgres, MariaDB...) tables or views</li>\n<li>to map those projections with read-only Doctrine entity classes <strong>and</strong> to mark those classes with <code class=\"language-text\">@ApiResource</code></li>\n</ul>\n<p>You can then benefit from the built-in Doctrine filters, sorting, pagination, auto-joins, etc provided by API Platform.</p>","editPath":"core/design.md","title":"General Design Considerations","previous":{"slug":"/docs/core/getting-started/","title":"Getting started"},"next":{"slug":"/docs/core/operations/","title":"Operations"}}}